#!/bin/bash
# =============================================================================
# EMERGENCY PROCESS KILL AUTOFIX SCRIPT
# =============================================================================
#
# ⚠️  EXTREME DANGER WARNING:
#   This script can KILL CRITICAL SYSTEM PROCESSES and render your system
#   UNBOOTABLE or UNRESPONSIVE. It includes extensive safety checks, but
#   killing the wrong process can crash your system instantly.
#
# PURPOSE:
#   Kills high-resource processes when system health is critically threatened.
#   Used when CPU, memory, or thermal conditions require immediate action to
#   prevent system crash or hardware damage.
#
# SAFETY MECHANISMS:
#   ✅ Never kills kernel threads ([process names])
#   ✅ Never kills critical system services (systemd, init, kernel workers)
#   ✅ Never kills SSH sessions (would lock out remote users)
#   ✅ Grace period prevents killing the same process repeatedly
#   ✅ Process validation before any kill action
#   ✅ Comprehensive logging of all actions
#
# CRITICAL PROCESSES PROTECTED:
#   ❌ init, systemd, kthreadd (PID 1, 2, etc.)
#   ❌ Kernel workers (kworker, ksoftirqd, migration)
#   ❌ SSH daemon and sessions (sshd)
#   ❌ Network services (NetworkManager, systemd-networkd)
#   ❌ Essential daemons (udev, dbus)
#   ❌ This monitoring system itself
#
# TRIGGER CONDITIONS:
#   - High CPU usage (thermal protection)
#   - Memory exhaustion (OOM prevention)
#   - System responsiveness issues
#   - Hardware protection (thermal, power)
#
# USAGE:
#   emergency-process-kill.sh <module> <grace_period> [reason] [value]
#
# SECURITY CONSIDERATIONS:
#   - PID validation prevents injection attacks
#   - Process existence verified before kill attempts
#   - No user input passed directly to kill commands
#   - All operations logged for security audit
#
# BASH CONCEPTS FOR BEGINNERS:
#   - 'kill -TERM' asks process to shut down gracefully
#   - 'kill -KILL' forces immediate termination (dangerous)
#   - PIDs (Process IDs) are unique numbers for each running process
#   - Critical processes keep your system running - never kill them!
#
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common.sh"

# Initialize autofix script with common setup
init_autofix_script "$@"

# Additional arguments specific to this script
TRIGGER_REASON="${3:-emergency}"
TRIGGER_VALUE="${4:-unknown}"

# Configuration loaded automatically via modules/common.sh

# =============================================================================
# show_help() - Display usage and critical safety information
# =============================================================================
show_help() {
    cat << 'EOF'
EMERGENCY PROCESS KILL AUTOFIX SCRIPT

⚠️  EXTREME DANGER WARNING:
    This script can KILL CRITICAL SYSTEM PROCESSES and render your system
    UNBOOTABLE. Only use when you understand the consequences.

PURPOSE:
    Kills high-resource processes when system health is critically threatened
    by CPU overload, memory exhaustion, or thermal emergencies.

USAGE:
    emergency-process-kill.sh <calling_module> <grace_period> [reason] [value]

ARGUMENTS:
    calling_module  - Name of monitoring module (e.g., "thermal")
    grace_period    - Seconds to wait before allowing kills again
    reason          - Why kill was triggered (e.g., "high_cpu")
    value           - Trigger value (e.g., "95%")

EXAMPLES:
    # Kill high-CPU process due to thermal emergency
    emergency-process-kill.sh thermal 300 high_cpu 95%

    # Kill memory-hungry process to prevent OOM
    emergency-process-kill.sh memory 600 high_memory 98%

SAFETY PROTECTIONS:
    ✅ Never kills init, systemd, kernel threads
    ✅ Never kills SSH sessions or network services
    ✅ Grace period prevents repeated kills
    ✅ Process validation before any action
    ✅ Comprehensive audit logging

KILL STRATEGY:
    1. Find highest resource-consuming non-critical processes
    2. Send SIGTERM (graceful shutdown) first
    3. Wait for process to exit cleanly
    4. Use SIGKILL only if SIGTERM fails
    5. Log all actions for audit

EXIT CODES:
    0 - Process killed successfully
    1 - Error occurred (check logs)
    2 - Skipped due to grace period

CRITICAL WARNING:
    Test thoroughly on non-production systems first!
    Killing the wrong process can crash your system instantly.
EOF
}

# Check for help request
if [[ "${1:-}" =~ ^(-h|--help|help)$ ]]; then
    show_help
    exit 0
fi

# =============================================================================
# is_system_critical_process() - Determine if a process is essential for system
# =============================================================================
#
# PURPOSE:
#   Identifies processes that should NEVER be killed because they're essential
#   for system operation. This is the primary safety mechanism preventing
#   system crashes.
#
# PARAMETERS:
#   $1 - pid: Process ID (must be numeric)
#   $2 - cmd: Command name or path
#
# RETURNS:
#   0 - Process IS critical (DO NOT KILL)
#   1 - Process is NOT critical (safe to kill)
#
# CRITICAL SAFETY LOGIC:
#   1. Kernel threads in [brackets] - NEVER kill (system will crash)
#   2. System daemons (systemd, init, dbus) - NEVER kill
#   3. Network services (SSH, NetworkManager) - would lock out users
#   4. Low PIDs (1-100) - Usually system processes
#   5. Essential services for basic system operation
#
# SECURITY CONSIDERATIONS:
#   - PID should be validated as numeric to prevent injection
#   - Command name matching should be exact to prevent false positives
#   - Should err on the side of caution (protect more rather than less)
#
# BASH CONCEPTS FOR BEGINNERS:
#   - 'case' statement matches patterns (like switch in other languages)
#   - '^\[.*\]$' is regex for "starts with [, anything in middle, ends with ]"
#   - 'return 0' means "success" (counterintuitive but true in bash)
#   - Low PID numbers (1, 2, etc.) are reserved for critical system processes
#
# EXAMPLES:
#   is_system_critical_process 1 "systemd"     # Returns 0 (critical)
#   is_system_critical_process 12345 "firefox" # Returns 1 (not critical)
#
is_system_critical_process() {
    local pid="$1"
    local cmd="$2"
    
    # SECURITY: Validate PID is numeric to prevent injection
    if [[ ! "$pid" =~ ^[0-9]+$ ]]; then
        autofix_log "ERROR" "SECURITY: Invalid PID format '$pid' - blocked"
        return 0  # Treat as critical to prevent action
    fi
    
    # Skip kernel threads (processes in brackets)
    if [[ "$cmd" =~ ^\[.*\]$ ]]; then
        return 0  # Critical
    fi
    
    # Skip essential system processes
    case "$cmd" in
        systemd|init|kthreadd|ksoftirqd|rcu_*|watchdog|migration|systemd-*|dbus|NetworkManager|sshd)
            return 0  # Critical
            ;;
        */systemd|*/init|*/dbus|*/NetworkManager|*/sshd)
            return 0  # Critical
            ;;
    esac
    
    # Skip processes with PID 1, 2, or in the first 100 PIDs (likely system)
    if [[ $pid -le 100 ]]; then
        return 0  # Critical
    fi
    
    return 1  # Not critical
}

# The actual emergency process kill action
perform_emergency_process_kill() {
    local trigger_reason="$1"
    local trigger_value="$2"
    
    autofix_log "INFO" "Emergency process kill request - Trigger: $trigger_reason ($trigger_value)"
    
    # Find the top CPU process first
    local target_pid target_pcpu target_cmd
    local found_target=false
    
    while IFS= read -r line; do
        local pid pcpu cmd
        read -r pid pcpu cmd <<< "$line"
        
        if [[ -n "$pid" && "$pid" =~ ^[0-9]+$ ]]; then
            local cpu_int=$(echo "$pcpu" | cut -d. -f1)
            
            # Only target processes using significant CPU
            if [[ $cpu_int -lt ${PROCESS_CPU_THRESHOLD:-10} ]]; then
                continue
            fi
            
            # Skip system critical processes
            if is_system_critical_process "$pid" "$cmd"; then
                autofix_log "DEBUG" "Skipping critical process: PID $pid ($cmd)"
                continue
            fi
            
            # Found our target
            target_pid="$pid"
            target_pcpu="$pcpu"  
            target_cmd="$cmd"
            found_target=true
            break
        fi
    done <<< "$(get_top_cpu_processes)"
    
    if [[ "$found_target" != "true" ]]; then
        autofix_log "WARN" "No suitable processes found for emergency kill (all processes below ${PROCESS_CPU_THRESHOLD:-10}% CPU or critical)"
        return 0  # Not an error - just no targets
    fi
    
    local app_name=$(basename "$target_cmd" | cut -d' ' -f1)
    autofix_log "INFO" "Target identified: $app_name (PID $target_pid, ${target_pcpu}% CPU)"
    
    # Check current status
    if ! kill -0 "$target_pid" 2>/dev/null; then
        autofix_log "INFO" "Target process PID $target_pid no longer exists"
        return 0
    fi
    
    # Re-check CPU usage to make sure it's still high
    local current_cpu
    current_cpu=$(ps -p "$target_pid" -o %cpu= 2>/dev/null | tr -d ' ' || echo "0")
    local current_cpu_int=$(echo "$current_cpu" | cut -d. -f1)
    
    if [[ $current_cpu_int -lt ${PROCESS_CPU_THRESHOLD:-10} ]]; then
        autofix_log "INFO" "Target process CPU usage dropped to $current_cpu% - no longer a threat"
        return 0
    fi
    
    # Send notifications before kill
    if command -v notify-send >/dev/null 2>&1; then
        notify-send -u critical "Emergency Process Kill" "Killing: $app_name (${current_cpu}% CPU)\nReason: $trigger_reason\nCaller: $CALLING_MODULE" 2>/dev/null || true
    fi
    
    autofix_log "INFO" "Terminating PID $target_pid ($app_name) - ${current_cpu}% CPU - trigger: $trigger_reason"
    
    # Try graceful termination first
    if kill -TERM "$target_pid" 2>/dev/null; then
        autofix_log "INFO" "Sent SIGTERM to PID $target_pid"
        
        # Wait for graceful shutdown
        local wait_time="${KILL_PROCESS_WAIT_TIME:-3}"
        sleep "$wait_time"
        
        # Check if process still exists
        if kill -0 "$target_pid" 2>/dev/null; then
            autofix_log "WARN" "Process PID $target_pid still running after SIGTERM, sending SIGKILL"
            if kill -KILL "$target_pid" 2>/dev/null; then
                autofix_log "INFO" "Sent SIGKILL to PID $target_pid"
            else
                autofix_log "ERROR" "Failed to send SIGKILL to PID $target_pid"
                return 1
            fi
        else
            autofix_log "INFO" "Process PID $target_pid terminated gracefully"
        fi
    else
        autofix_log "ERROR" "Failed to send SIGTERM to PID $target_pid"
        return 1
    fi
    
    # Final verification
    sleep 1
    if kill -0 "$target_pid" 2>/dev/null; then
        autofix_log "ERROR" "Process PID $target_pid still running after both SIGTERM and SIGKILL"
        return 1
    else
        autofix_log "INFO" "Process $app_name (PID $target_pid) successfully terminated"
        
        # Send success notification
        if command -v notify-send >/dev/null 2>&1; then
            notify-send "Emergency Kill Complete" "Successfully terminated: $app_name\nCPU usage: ${current_cpu}%\nReason: $trigger_reason" 2>/dev/null || true
        fi
        
        return 0
    fi
}

# Execute with grace period management
autofix_log "INFO" "Emergency process kill requested by $CALLING_MODULE with ${GRACE_PERIOD}s grace period"
run_autofix_with_grace "emergency-process-kill" "$CALLING_MODULE" "$GRACE_PERIOD" "perform_emergency_process_kill" "$TRIGGER_REASON" "$TRIGGER_VALUE"